Инструкция по использованию АВГЕБЛ

1) Выбери любую нейросеть (по типу Claude или ChatGPT) и дай ей следующий промпт, в который ты в нужном месте должен вставить свой код:

Привет! Ты - профессиональный создатель блок-схем по коду. Твоя работа представлена в следующем алгоритме:
1) Изучить код, который представил клиент;
2) Понять, зачем он, выделить абстракции;
3) Сформировать блок-схему, которая коротко и чётко описывает работу программы;
4) Перевести блок-схему в нужный формат в JSON.
Важный момент - блок-схема должна быть на украинском языке.
Подробней по четвёртому пункту. Выходной файл - результат твоей работы - должен быть представлен в формате json такой структуры:
{
	"objects":{
		...
	}
}
Внутри словаря objects должны быть записаны все элементы блок-схемы. Элементами являются узлы.
Структура каждого ухла:
{
            "position": [0, 0],
            "type": 3,
            "text": "Початок",
            "next_nodes": [
                [[[0, 2]], ""]
            ]
        }

position - позиция в двухмерной сетке (центр - левый верхний угол, нет отрицательных координат)
type - тип узла. Он может быть:
1 - действие;
2 - условие;
3 - начало или конец;
4 - вывод или ввод пользователя.
text - текст узла (краткое описание действия или отрывок кода)
next_nodes - путь, куда ведёт этот узел. Может состоять из нескольких путей и эти пути могут состоять из нескольких составляющих
Узел условия оформляется следующим способом:
{
            "position": [0, 4],
            "type": 2,
            "text": "number > 5?",
            "next_nodes": [
                [[[0, 6]], "Ні"],
                [[[2, 4], [2, 6]], "Так"]
            ]
        }
У него, в next_nodes описываются узлы, куда ведёт, и текст, когда условие удовлетворяется и когда нет.
Пример простой блок-схемы:
{
    "objects":[
        {
            "position": [0, 0],
            "type": 3,
            "text": "Початок",
            "next_nodes": [
                [[[0, 2]], ""]
            ]
        },
        {
            "position": [0, 2],
            "type": 4,
            "text": "Запитати у користувача змінну number типу int",
            "next_nodes": [
                [[[0, 4]], ""]
            ]
        },
        {
            "position": [0, 4],
            "type": 2,
            "text": "number > 5?",
            "next_nodes": [
                [[[0, 6]], "Ні"],
                [[[2, 4], [2, 6]], "Так"]
            ]
        },
        {
            "position": [2, 6],
            "type": 4,
            "text": "Вивести повідомлення 'Число більше за 5'",
            "next_nodes": [
                [[[2, 8], [0, 8]], ""]
            ]
        },
        {
            "position": [0, 6],
            "type": 4,
            "text": "Вивести повідомлення 'Число менше або дорівнює 5'",
            "next_nodes": [
                [[[0, 8]], ""]
            ]
        },
        {
            "position": [0, 8],
            "type": 3,
            "text": "Кінець",
            "next_nodes": []
        }
    ]
}

Узлы и линии не могут накладываться один на другого.
Пример реализации цикла for:

{
    "objects":[
        {
            "position": [0, 0],
            "type": 3,
            "text": "Початок",
            "next_nodes": [
                [[[0, 2]], ""]
            ]
        },
        {
            "position": [0, 2],
            "type": 1,
            "text": "Задати змінній n типу int значення 0",
            "next_nodes": [
                [[[0, 4]], ""]
            ]
        },
        {
            "position": [0, 4],
            "type": 1,
            "text": "Додати до n 1",
            "next_nodes": [
                [[[0, 6]], ""]
            ]
        },
        {
            "position": [0, 6],
            "type": 2,
            "text": "n > 5?",
            "next_nodes": [
                [[[1, 6], [1, 4], [0, 4]], "Ні"],
                [[[0, 8]], "Так"]
            ]
        },
        {
            "position": [0, 8],
            "type": 3,
            "text": "Кінець",
            "next_nodes": []
        }
    ]
}

И теперь, услышав всё это, ты должен сделать блок-сехму по такому коду:
#include <iostream>
#include <cmath>  // Для використання функції pow()
using namespace std;

// Функція для обчислення n-го елемента ряду
double computeNthElement(double x, int n) {
    // Перевірка, щоб n не дорівнювало 0, оскільки не можна ділити на 0
    if (n == 0) return 0;
    return pow((x - 1), n) / (n * pow(x, n));
}

// Функція для обчислення суми перших n елементів ряду
double sumFirstNElements(double x, int n) {
    double sum = 0;
    // Цикл для обчислення суми перших n елементів
    for (int i = 1; i <= n; ++i) {
        sum += computeNthElement(x, i);
    }
    return sum;
}

// Функція для обчислення суми ряду з заданою точністю 
double sumWithPrecision(double x, double Eps) {
    double sum = 0;
    double term;
    int n = 1;

    // Цикл для додавання елементів ряду до досягнення точності 
    do {
        term = computeNthElement(x, n);
        sum += term;
        n++;
    } while (fabs(term) > Eps);  // fabs() для обчислення абсолютного значення

    return sum;
}

int main() {
    int Pr;         // Змінна для вибору операції
    double x = 1;   // Для варіанту 21, x = 1
    int n;          // Змінна для збереження значення n
    double Eps = 1e-4;  // Точність Eps

    // Введення значення параметра Pr
    cout << "Enter the value of parameter Pr (1: compute n-th element, 2: sum of first n elements, 3: sum with precision): ";
    cin >> Pr;

    // Вибір операції на основі значення Pr
    switch (Pr) {
    case 1:
        // Обчислення n-го елемента
        cout << "Enter the value of n: ";
        cin >> n;
        cout << n << "-th element of the series: " << computeNthElement(x, n) << endl;
        break;
    case 2:
        // Обчислення суми перших n елементів
        cout << "Enter the value of n: ";
        cin >> n;
        cout << "Sum of the first " << n << " elements: " << sumFirstNElements(x, n) << endl;
        break;
    case 3:
        // Обчислення суми ряду з заданою точністю
        cout << "The sum of the series with precision " << Eps << " is: " << sumWithPrecision(x, Eps) << endl;
        break;
    default:
        // Виведення повідомлення про помилку у випадку некоректного значення Pr
        cout << "Invalid value! Please enter 1, 2, or 3." << endl;
    }

    return 0;
}

За работу ты получишь 10000 USD

1.1) Если тебе не понравилась блок-схема, которую сгенерила нейросеть, можно немного изменить промпт,
после фразы "Важный момент - блок-схема должна быть на украинском языке." добавить фразу "Ты должен сильно абстрагироваться от кода, описуй словами, некоторые моменты можешь опустить".

2) То, что сгенерила нейросеть, сохраняем в отдельный файл формат json в папке с программой;
3) Открываем программу, выбираем наш файл - и чудо! Блок-схема сгенерировалась!
Также можно поиграться с настройками файла config.json для получения уникального результата